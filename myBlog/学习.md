## html5 新特性
+ 新的语义元素，比如 header, footer, article, section
+ 新的媒体元素，比如 audio，video
+ 新的动画元素，canvas，svg

## 明白结构赋值 ```...```
### 数组解构
```javascript
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = ["foo", "bar", "baz"];
third // "baz"

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
```
如果解构不成功，变量的值就等于undefined。

```javascript
let [foo] = [];
let [bar, foo] = [1];
```
以上两种情况都属于解构不成功，foo的值都会等于undefined。

另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。

```javascript
let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```
上面两个例子，都属于不完全解构，但是可以成功。

### 对象解构
```javascript
let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
foo // "aaa"
bar // "bbb"

let { baz } = { foo: 'aaa', bar: 'bbb' };
baz // undefined
```

如果变量名与属性名不一致，必须写成下面这样。
```javascript
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"

let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;
f // 'hello'
l // 'world'
```

这实际上说明，对象的解构赋值是下面形式的简写

```javascript
let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };
```
也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。后者才是变量，而不是前者。

```javascript
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"
foo // error: foo is not defined
```
上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。

## css 会影响页面加载吗？
[https://juejin.cn/post/6844903667733118983](https://juejin.cn/post/6844903667733118983)

总结：
* css并不会阻塞DOM树的解析，但是css加载会阻塞DOM树渲染
* css加载会阻塞后面的js语句的执行，js加载也会阻塞css加载

因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:

* 使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)
* 对css进行压缩(可以用很多打包工具，比如webpack)
* 合理的使用缓存(设置cache-control,expires,或者E-tag)
* 减少http请求数，将多个css文件合并

## 页面加载慢，怎么优化？

